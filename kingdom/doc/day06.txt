#day 06

--------------------------------------------------------------------------------------------------------------------
멤버(Member)
	- 클래스는 해당 클래스의 속성을 기억할 변수와 가지는 기능을 만들어놓은 함수로 이루어져있다.
	
	- 따라서 클래스가 객체가 되면 변수와 함수도 사용할 수 있게 된다.
	
	- 이때 이 변수와 함수를 멤버라고 표현한다.
	
	
따라서 클래스가 가지는 변수와 함수를 사용하는 방법은 먼저 클래스를 객체로 만든 후 사용해야 한다.

	형식 
	
		클래스이름 변수이름 = new 클래스이름();
		변수이름.변수;
		변수이름.함수();
--------------------------------------------------------------------------------------------------------------------

함수의 오버로딩(Overloading:함수의 중첩)
	=> 원칙적으로 같은 클래스 안에는 함수의 이름은 모두 달라야한다.
		같은 클래스 안에서 같은 이름의 함수가 존재하면 에러가 발생한다.
		이러다보니 가독성에 문제가 발생한다.
		가독성이란 ? 
			함수의 이름만봐도 그 함수가 어떤 기능을 가지고 있는 함수인지 알 수 있어야하는것.
			그러므로 함수의 이름을 다르게 만들다보면 가독성에 문제가 발생할 수 있다.
		이런 불편함을 해결하기 위해서 도입된 문법이 함수의 "오버로딩"이다.
		
		함수의 오버로딩이란?
			같은 클래스안에서 같은 이름의 함수를 만들 수 있다.
			단, 다음 조건은 반드시 지켜야한다.
			
				오버로딩 조건
					0. 함수가 존재해야한다.
					1. 함수의 이름이 같아야한다.
					2. 매개변수리스트가 달라야한다.
						-> 변수이름은 상관없고, 갯수 또는 순서가 달라야한다.
					3. 반환값과는 전혀 상관없다.
					
	***
	오버로딩은 함수의 매개변수, 갯수, 순서, 형태 중 하나 이상이 달라야 한다.
--------------------------------------------------------------------------------------------------------------------
	
생성자 함수(Constructor)
=> 클래스를 사용하기위해 객체로 만드는 new 시키는 순간 자동 실행되는 함수

	즉, 클래스를 new 시킨다는 것은 오브젝트로 만들어서 실행한다는 의미.
	따라서 이때 실행한다는 개념은 결국 오브젝트(객체)를 만드는 순간 뭔가를 실행한다는 개념이다.
	
	이것은 물건을 만들때 필요한 뭔가 조치를 한다는 개념.
	=> 결론적으로 실제로 실행 가능한 것으로 만들기 위한 함수. 
	
	클래스는 한가지 목적을 달성하기 위해서 만들어진 프로그램의 기본단위이다.
	이 안에는 그 목적을 달성하기 위해 변수, 함수로 구성된다.
	하지만 그 목적을 달성하기 위해서는 기본적으로 어떤 조치가 필요한 경우가 있다.
	
	예
		String 
			=> 문자열 관리할 목적으로 만들어진 클래스
			=> 문자열을 기억하고 있어야한다.
		FileOutputStream
			=> 파일에 내용을 기록하기 위한 목적으로 만들어진 클래스
			=> 파일을 사용할 수 있도록 열어놓아야 할 것.
		Socket
			=> 네트워크를 구성하기위한 목적으로 만들어진 클래스
			=> 상대방과 접속은 이루어져야 할 것이다.
			
	프로그램은 프로그램답게 뭔가를 처리하기 위해서 함수가 필요하다.
	위의 경우를 비추어보면 각각의 클래스는 오브젝트로 만들어지는 순간 그 클래스만의 최소한의 일을 할 필요가 있다.
	
	바로 이런일을 하기위해 만들어 놓은 함수를
	"생성자(Constructor)"라고 부른다.
	
	생성자 함수를 만드는 이유는 만들고자 하는 클래스의 목적에 따라 그 클래스가 해야할 가장 기본적인 일을 처리하기
	위해서 만드는 것이다.
	
	생성자함수 만드는 방법
		 1. 함수의 이름은 반드시 클래스 이름과 동일.
		 2. 반환값은 절대로 가지면 안된다.
		 3. 매개변수는 가질 수 있다.
		 
	주의사항
		생성자 함수를 만들지 않아도 사용할 수 있다.
		이때는 자바가상머신(JVM)이 기본생성자를 만들어서 호출하게 된다.
		생성자 함수를 하나라도 정의하게 되면 이때는 자바가상머신이 기본생성자를 만들지 않는다.
		따라서 생성자를 정의할 때에는 반드시 기본생성자(매개변수가 없는 생성자)도 같이 정의하는 것이 좋다.
		
	참고
		생성자함수도 오버로딩이 가능하다.
		=> 생성자 함수도 여러개로 정의할 수 있다.
	생성자 함수 이용방법
		생성자 함수는 그 클래스를 어떻게 new 시킬지 알려주는 함수.
		즉, 생성자함수가 요구하는 매개변수가 무엇인지를 알면 그 클래스를 객체로 만들 수 있다.
	
	참고
		this()
		=> 생성자 함수는 원칙적으로 개발자가 직접 호출할 수 없다.
			현재 생성자를 실행하는 도중에 다른 형태의 현재 클래스의 형체를 강제로 호출하는 유일한 방법.
		=> 현재 실행중인 객체 자기자신을 가리키는 예약어

		***
			규칙 
				1. 반드시 생성자 안에서만 사용할 수 있다. 일반함수 내에서는 절대로 사용할 수 없다.
				2. 반드시 생성자 함수의 첫문장, 첫 명령으로 사용해야 한다. 이전에 다른 문장이 있으면 에러가 발생한다.
--------------------------------------------------------------------------------------------------------------------
접근지정자
	=> 그 내용을 누구(어디)까지 사용할 수 있는지 지정하는 예약어
	즉, 우리가 클래스를 만든다고 해서 그 클래스(내용)을 모든 사람에게 공개해야 되는것은 아니다
	
	예
		클래스는 어디까지 이 클래스를 사용할 수 있도록 할까?
		함수는 어디까지 이 함수를 호출할 수 있도록 할까?
		
		
	종류
		1. public
			: 모든 곳에서 사용할 수 있다.
		2. protected
			: 상속 받은 하위 클래스 + 같은 패키지 소속에서만 사용할 수 있다.
		
		3. 생략
			: 같은 패키지 안에서는 사용할 수 있다.
			
		4. private
			: 같은 클래스 안에서만 사용할 수 있다.
			
	참고
	
		클래스에는 public, 생략만 사용가능하다.
		
***
은닉화
	프로그램에 있어서 가장 중요한 요소는 데이터이다.
	즉, 변수가 프로그램의 핵심적인 요소가 된다는 것이다.
	무결성 데이터를 유지할 수 있는 것이 가낭 중요한 개념이다.
	
	은닉화란?
		이처럼 중요한 요소인 변수를 사용자가 함부로 변경하지 못하도록
		방지하는 기술을 이야기한다.
		(결점이 있는 데이터가 발생하지 않도록 하는 것)
		
		방법
			1. 데이터가 기억될 변수는 private으로 처리한다.
				(이렇게 처리하면 다른 클래스 에서는 데이터 입력, 열람도 불가능해진다.)
			2. 이 변수의 값을 변경하거나 읽을 수 있는 기능이 있는 함수를 만들어 준다.
				=> Getters & Setters 함수이다. (source -> generate getter setter 메뉴 이용)
--------------------------------------------------------------------------------------------------------------------
this 
==> 현재 실행중인 오브젝트의 주소를 기억하는 약속된 변수
	이것은 JVM이 클래스를 처리하기위해서 JVM이 사용하는 변수
	
	규칙
		1. 모든 멤버는 사용할 때 반드시 앞에 주소가 있어야한다
			멤버는 클래스 안에 만들어진 변수나 함수를 이야기한다.
			
			따라서 new 를 시킨 후 그 주소를 기억해 놓았다가 그 주소를 이용해서 사용하는 것.
			
		2. 만약 주소가 없으면 JVM이 자동적으로 this를 붙여준다.
		3. 멤버함수를 호출할 때는 무조건 주소값을 함수에게 알려주도록 약속했고
			함수는 호출할 때 알려준 주소를 기억하게 된다.
	참고
		딱 한번 this를 개발자가 사용해야 하는 경우가 있다.
		
		지역변수와 멤버변수가 이름이 동일하게 만들어지는 경우가 발생할때 따로 지정하지 않으면
		변수는 지역변수를 사용하게 된다. (가까운쪽 변수를 먼저 찾기때문)
		따라서 멤버 변수에 데이터가 기억되지 않을 수 있다.
		이때 굳이 이 변수가 멤버 변수임을 명확하게 밝혀주고싶은 경우가 생기면 이때 강제로 this라고 붙여준다.
--------------------------------------------------------------------------------------------------------------------

클래스 만드는 형식
	[접근지정자] [속성] class 클래스이름 {}
	[접근지정자] [속성] 반환값타입 함수이름(매개변수리스
	[접근지정자] [속성] 데이터타입 변수이름;
	
속성
	static 
		==> static영역에 생기는 함수나 변수들에게 붙여주는 속성
		
		참고
			클래스, 함수, 변수를 만들때 속성을 지정해줄 수 있다.
			
		특징
			1. 프로그램이 실행되기 위해서 JVM이 로딩하는 순간 저절로 생기는 영역
				사용자가 별도로 만들어달라고 요구하지않아도 자동적으로 생기는 영역
			2. 한번 만들어진 변수나 함수는 두번 생기지 않는다.
			
	static 변수
		==> static 영역에 만들어지는 변수
	static 함수
		==> static 영역에 만들어지는 함수
		형식
			[접근지정자] static 데이터타입 변수이름;
			
		특징
			1. 여러 오브젝트(객체)가 공동으로 사용하는 변수가 된다.
				<== 오브젝트를 100개를 만들어도 static 변수는 오직 한개만 static 영역에 생기므로	
				
					따라서 한 객체에서 데이터를 바꾸면 다른 객체에서도 바뀐 데이터를 사용해야한다.
					
			2. new 시키지않아도 사용할 수 있는변수
				==> 이미 메모리에 올려져있기 때문
				
		사용방법
			
			클래스이름.변수이름;
			
	static 함수
		==> static 영역에 만들어지는 함수
			따라서 객체가 만들어지지 않아도 사용할 수 있는 함수
			
		사용방법 
			클래스이름.함수이름();
			
		***
		이 함수는 this를 사용할 수 없는 함수이다.
		
		결론
			static 함수 안에서는 static 멤버만 사용할 수 있다.
			일반 함수 안에서는 static멤버와 일반멤버도 사용할 수 있다.

--------------------------------------------------------------------------------------------------------------------
멤버 변수의 초기화
==> 멤버 변수는 heap 영역에 생기므로 자동 초기화가 된다.
	하지만 가끔은 변수에 기본적인 값을지정할 필요가 있다.
	
	1. 명시적 초기화
		==> 변수를 선언하면서 값을 입력하는것.
			가장 먼저 실행된다.
			
			예
				class Test{
					int no = 10; // 명시적 초기화
				}
	2. 초기화 블럭을 이용한 초기화
		==> 이것은 인스턴스 변수에 대해서만 가능한 것으로
			두번째로 실행되는 방법
			클래스블럭 바로 밑에 위치
			
			형식
				{
					이 안에 데이터를 변수에 입력
				}
				
			예
				class Test{
					int no;
					{
						no = 100;
					{
				{
				
				
	3. static 블럭을 이용한 초기화
	
		==> 2번과 비슷한데 static 변수에 한해서만 적용되는 방법
			두번째로 실행되는 방법
			
			형식
				static {
					변수에 데이터 입력
				
				}
			예
				class Test{
					static int no;
					static {
						no = 1000; // static 블럭을 이용한 초기화
					}
				}
				
	4. 생성자 함수를 이용한 초기화
		==> 제일 마지막에 실행되는 방법
		예
			class Test{
				int no;
				public Test(){
					this.no = 1000;		
				}
				
			}
			
--------------------------------------------------------------------------------------------------------------------
상속
==> 이미 만들어진 클래스의 기능을 그대로 물려받아서
	(변수와 함수의 기능을 그대로 복사 받아서)
	새로운 클래스를 만드는 방법
	
	이 개념이 나타나게된 이유?
		<== 소프트웨어의 개발속도를 바르게 하기위한 방법중의 한가지
		
	객체지향언어는 부품단위(클래스)로 프로그램을 만든 후 그 부품들을 조립해서 원하는 결과를 얻어내는 언어.
	
	상속은 자신이 만들고자하는 부품과 가장 유사한 부품을 가지고와서 일단 그 기능을 복사한 후,
	1. 없는기능만 덧붙이고
	2. 있는 기능 중 바꿀 내용은 수정하고 
	
	형식
		class 클래스 이름 extends 상속받을 클래스 이름{
			함수를 수정 또는 추가작업
		}
	참고
		자바는 단일 상속만 가능하다.
		
		예
			class Test extends String, Integer{ // 절대로안된다. 단일상속만 가능
			}
--------------------------------------------------------------------------------------------------------------------
			
	용어정리
		상속을 해준 클래스 : Super Class, 상위클래스, 부모클래스, 조상클래스
		상속을 받은 클래스 : Sub Class, 하위클래스, 자식클래스, 자손클래스
		
	상속관계에 있는 경우 생성자의 역할
	
		결론적으로 
			하위클래스가 생성되는순간 상위클래스가 자동 생성된다.
			==> 생성되는 순간간 생성자 함수가 호출된다.
				결국 하위클래스를 생성하면 상위클래스의 생성자함수도 실행된다.
		결국 상위클래스의 생성자 함수는 자동호출되는 개념이다.
		이때 호출되는 생성자함수는 무조건 기분 생성자만 이용하게 된다.
		
		***
		참고
			super : 실행중인 객체의 상위 클래스를 기억하는 변수
					this가 실행중인 객체 자기자신을 기억하는 예약된 변수이듯이
					super역시 예약된 변수 중 하나이다.
					자신의 상위 클래스의 주소가 기억되는 변수
				사용목적
					반드시 소속을 밝혀야할 필요가 있는 경우 사용한다.
					
					
			super() : 상위 클래스의 특별한 생성자 함수를 호출할 수 있는 유일한 방법.
						this() 와 같이 생성자의 첫줄 첫문자로만 사용할 수 있다.
						
			public class Test extends Example{
				public Test(){
					//super(); // 얘가 생략되어있음.
							// 상위클래스의 생성자를 호출하지 않으면 이 함수가 호출되는 것이다.
					super(데이터); // 상위 클래스의 기본생성자가 아닌 생성자를 호출 하는 방법	
					....				
				}			
			}
--------------------------------------------------------------------------------------------------------------------
***
오버라이딩(Overriding : 함수의 재정의)
==> 상속관계에 있는 하위클래스에서 상위클래스가 가진 함수의 기능을 수정하는 행위

	방법
		0. 상위클래스가 해당함수를 가지고 있어야한다. 
		1. 상위클래스가 가진 함수의 원형과 동일한 원형으로 만들어야한다.
			참고 
				함수의 원형(Prototype) :
						반환값 + 함수이름 + 매개변수리스트

		2. 접근지정자는 같거나 넓은 방향으로 써준다
		3. 예외처리는 같거나 좁은 방향으로 써준다.						
	
	이렇게 오버라이딩을 하게되면 내부적으로 상위 클래스가 가진 함수가 숨겨지고 재정의한 함수가 실행된다.
		
--------------------------------------------------------------------------------------------------------------------

***
다형성
==> 하나의 변수를 이용해서 여러 형태의 클래스를 사용하도록 하는 기법
	
	주소의 형변환(Casting)			
	==> 원칙적으로 주소는 다른 형태로 형변환이 불가능하다.
		즉, 주소는 heap형태에 따라 주소가 결정되므로 Heap 형태가 다르면 주소를 기억할 수 없다.
		
		예
			int[] a = new int[5];  --> O
			
			Test t = new Ex01();   --> X
			
			***
			오직 한가지 경우에 한해서 주소의 형변환이 가능하다.
			상속관계에 있는 클래스끼리는 형변환이 가능하다.
			
			이런 관계를 is a 관계라고 한다.
			
			참고
				has a : 멤버로 가지고 있는지를 묻는 것.
				
			자동 형변환
				하위클래스의 주소가 상위클래스의 변수에 기억되는 것은 자동적으로 형변환을 해준다.
				
				예
					망둥어는 물고기다.
			강제 형변환
				상위 클래스의 주소가 하위 클래스 변수에 기억되는 것은 원칙적으로 불가능하며 강제로 형변환 해줄 수 있다.
				
			class Grand{
				void abc(){
					System.out.println(" 여기는 Grand");
				}
			}
			
			class Father extends Grand{
				void abc(){
					System.out.println("여기는 아부지");
				}
				void xyz(){
					System.out.println("한글 사랑");
				}
			}
			
			class Son extends Father{
				void abc(){
					System.out.println("여기는 Son 클래스");
				}
			}
			
			Son s = new Son();	--> O
			Father f = s;
			
			Father f1 = new Father();
			Son s1 = f1;		--> X , father의 범위가 더 넓기 때문에
			Son s1 = (Son)f1;	--> O , 강제 형변환
		
			다형성이란?
			주소의 형변환이론을 기반으로 하여 상위 클래스의 주소를 이용해서 하위 클래스를 이용할 수 있으며
			상위클래스의 주소를 이용하면 여러 하위클래스를 다룰 수 있다.
			
		참고
			변수는 래퍼런스쪽을 따르고 함수는 인스턴스쪽을 따른다.
	